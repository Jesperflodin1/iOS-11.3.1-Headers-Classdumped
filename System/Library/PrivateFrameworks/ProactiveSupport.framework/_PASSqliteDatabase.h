/*
* This header is generated by classdump-dyld 1.0
* on Wednesday, August 22, 2018 at 12:26:19 AM Central European Summer Time
* Operating System: Version 11.3.1 (Build 15E302)
* Image Source: /System/Library/PrivateFrameworks/ProactiveSupport.framework/ProactiveSupport
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013-2016 by Elias Limneos.
*/


@protocol _PASSqliteErrorHandlerProtocol, OS_dispatch_queue;
#import <ProactiveSupport/ProactiveSupport-Structs.h>
@class NSObject, NSString, NSCache, NSOperationQueue;

@interface _PASSqliteDatabase : NSObject {

	sqlite3Ref _db;
	int _transactionDepth;
	BOOL _transactionRolledback;
	atomic_flag _isClosed;
	NSObject*<_PASSqliteErrorHandlerProtocol> _errorHandler;
	NSString* _filename;
	NSCache* _queryCache;
	NSObject*<OS_dispatch_queue> _queue;
	NSObject*<OS_dispatch_queue> _workQueue;
	NSOperationQueue* _operationQueue;
	opaque_pthread_t* _threadInQueue;
	opaque_pthread_mutex_t _threadInQueueLock;
	BOOL _currentExclusivity;
	BOOL _isInMemory;

}

@property (nonatomic,readonly) sqlite3Ref handle; 
@property (nonatomic,readonly) NSString * filename;              //@synthesize filename=_filename - In the implementation block
@property (nonatomic,readonly) BOOL isInMemory;                  //@synthesize isInMemory=_isInMemory - In the implementation block
+(id)sqliteDatabaseWithFilename:(id)arg1 contentProtection:(long long)arg2 error:(id*)arg3 errorHandler:(id)arg4 ;
+(id)recreateCorruptDatabase:(id)arg1 withContentProtection:(long long)arg2 ;
+(id)initializeDatabase:(id)arg1 withContentProtection:(long long)arg2 newDatabaseCreated:(BOOL*)arg3 errorHandler:(id)arg4 ;
+(id)sqliteDatabaseWithFilename:(id)arg1 contentProtection:(long long)arg2 error:(id*)arg3 ;
+(id)sqliteDatabaseWithFilename:(id)arg1 flags:(int)arg2 error:(id*)arg3 errorHandler:(id)arg4 ;
+(id)sqliteDatabaseWithFilename:(id)arg1 error:(id*)arg2 errorHandler:(id)arg3 ;
+(id)sqliteDatabaseInMemoryWithError:(id*)arg1 errorHandler:(id)arg2 ;
+(id)protectedDatabaseWithFilename:(id)arg1 error:(id*)arg2 errorHandler:(id)arg3 ;
+(void)runDebugCommand:(const char*)arg1 onDbWithHandle:(id)arg2 ;
+(id)initializeDatabase:(id)arg1 withContentProtection:(long long)arg2 newDatabaseCreated:(BOOL*)arg3 ;
+(BOOL)shouldCacheSql:(const char*)arg1 ;
+(BOOL)isInMemoryPath:(id)arg1 ;
+(id)sqliteDatabaseWithFilename:(id)arg1 flags:(int)arg2 error:(id*)arg3 ;
+(id)sqliteDatabaseWithFilename:(id)arg1 error:(id*)arg2 ;
+(id)sqliteDatabaseInMemoryWithError:(id*)arg1 ;
+(id)protectedDatabaseWithFilename:(id)arg1 error:(id*)arg2 ;
+(id)inMemoryPath;
+(id)randomlyNamedInMemoryPathWithBaseName:(id)arg1 ;
+(void)truncateDatabaseAtPath:(id)arg1 ;
+(id)initializeDatabase:(id)arg1 withProtection:(BOOL)arg2 newDatabaseCreated:(BOOL*)arg3 ;
+(id)corruptionMarkerPathForPath:(id)arg1 ;
-(sqlite3Ref)handle;
-(id)init;
-(void)dealloc;
-(id)description;
-(NSString *)filename;
-(id)initWithFilename:(id)arg1 flags:(int)arg2 error:(id*)arg3 errorHandler:(id)arg4 ;
-(void)withDbLockExecuteBlock:(/*^block*/id)arg1 ;
-(void)withDbLockExecuteAsyncBlock:(/*^block*/id)arg1 ;
-(BOOL)createSnapshot:(id)arg1 ;
-(void)insertIntoTable:(id)arg1 dictionary:(id)arg2 ;
-(BOOL)setUserVersion:(unsigned long long)arg1 ;
-(unsigned long long)userVersion;
-(id)initWithFilename:(id)arg1 flags:(int)arg2 error:(id*)arg3 ;
-(void)closePermanently;
-(void)simulateOnDiskDatabase;
-(long long)lastInsertRowId;
-(BOOL)runQuery:(id)arg1 onRow:(/*^block*/id)arg2 onError:(/*^block*/id)arg3 ;
-(BOOL)runQuery:(id)arg1 onRow:(/*^block*/id)arg2 ;
-(BOOL)prepQuery:(id)arg1 onPrep:(/*^block*/id)arg2 onError:(/*^block*/id)arg3 ;
-(BOOL)prepAndRunQuery:(id)arg1 onPrep:(/*^block*/id)arg2 onRow:(/*^block*/id)arg3 onError:(/*^block*/id)arg4 ;
-(void)_prepAndRunQuery:(id)arg1 columns:(id)arg2 dictionary:(id)arg3 onError:(/*^block*/id)arg4 ;
-(BOOL)prepAndRunNonDataQueries:(id)arg1 onError:(/*^block*/id)arg2 ;
-(void)updateTable:(id)arg1 dictionary:(id)arg2 whereClause:(id)arg3 onError:(/*^block*/id)arg4 ;
-(void)insertOrReplaceIntoTable:(id)arg1 dictionary:(id)arg2 onError:(/*^block*/id)arg3 ;
-(id)selectColumns:(id)arg1 fromTable:(id)arg2 whereClause:(id)arg3 onPrep:(/*^block*/id)arg4 onError:(/*^block*/id)arg5 ;
-(void)writeTransaction:(/*^block*/id)arg1 ;
-(BOOL)frailWriteTransaction:(/*^block*/id)arg1 ;
-(void)readTransaction:(/*^block*/id)arg1 ;
-(BOOL)frailReadTransaction:(/*^block*/id)arg1 ;
-(void)_txnBegin;
-(void)_txnBeginExclusive;
-(void)_txnRollback;
-(void)_txnEnd;
-(BOOL)_transactionWithExclusivity:(BOOL)arg1 transaction:(/*^block*/id)arg2 ;
-(BOOL)hasTableNamed:(id)arg1 ;
-(id)tablesWithColumnNamed:(id)arg1 ;
-(BOOL)hasColumnOnTable:(id)arg1 named:(id)arg2 ;
-(BOOL)hasIndexNamed:(id)arg1 ;
-(unsigned long long)numberOfRowsInTable:(id)arg1 ;
-(id)languageForFTSTable:(id)arg1 ;
-(BOOL)isInMemory;
-(void)placeCorruptionMarker;
-(BOOL)handleError:(long long)arg1 sqliteError:(int)arg2 forQuery:(id)arg3 onError:(/*^block*/id)arg4 ;
-(id)freeSpace;
-(id)dbErrorWithCode:(unsigned long long)arg1 sqliteReturnValue:(int)arg2 lastErrno:(int)arg3 query:(id)arg4 ;
-(void)clearCaches;
@end

